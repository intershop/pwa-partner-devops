################################################################################
# Parameters have to be specified by the caller, to customize the pipeline
# for a certain project
################################################################################
parameters:

  # Identifies each job uniquely when ci-job-template.yml is used in a loop. 
  # Can only contain characters, numbers, and underscores.
  # Also used to extend names of files published in extensions.
- name: id
  type: string
  default: ''
  
  # Enables an easy integration with custom jobs. 
  # The parameter will be passed as is to the 'dependsOn' property of the job.
- name: dependsOn
  type: string
  default: ''

  # Enables an easy integration with custom jobs. 
  # The parameter will be passed as is to the 'condition' property of the job.
- name: condition
  type: string
  default: ''

  # Specifies the name of the agent pool.
- name: agentPool
  type: string
  default: ''

  # Defines the service connection to the Registry/ACR of the project.
- name: registryServiceConnection
  type: string
  default: ''

  # Specifies the repository in Registry/ACR url.
- name: registry
  type: string
  default: ''

  # Specifies the name of the repository.
- name: projectPath
  type: string
  default: '$(Build.Repository.Name)'

  # Specifies a predefined image tag. 
  # If not set, it will be generated by build ID or tag value.
- name: predefinedImageTag
  type: string
  default: ''

  # Specifies a predefined image name. If not set, it will be generated by 
  # $(System.CollectionUri) and $(System.TeamProject) and $(Build.SourceBranchName).
- name: predefinedImageName
  type: string
  default: ''

  # Specifies the name of the predefined SSR container.
- name: ssrBaseImageName
  type: string
  default: 'pwa-ssr'

  # Specifies the name of the predefined Nginx container.
- name: nginxBaseImageName
  type: string
  default: 'pwa-nginx'

  # Enable immutable images when created for Git tags.
- name: lockImages
  type: boolean
  default: true
  
  # Specifies the maximum job execution time in minutes.
- name: jobTimeoutInMinutes
  type: number
  default: 300

  # Specifies whether future jobs should run even if this job fails.
- name: jobContinueOnError
  type: boolean
  default: false

  # Enable this to retag builded Docker images for tags instead of rebuilding them.
- name: retagExistingImages
  type: boolean
  default: false

jobs:
- job: CI${{ parameters.id }}
  pool: '${{ parameters.agentPool }}'
  dependsOn: ${{ parameters.dependsOn }}
  condition: ${{ parameters.condition }}
  continueOnError: ${{ parameters.jobContinueOnError }}
  timeoutInMinutes: ${{ parameters.jobTimeoutInMinutes }}
  workspace:
    clean: all
  steps:
    # Checkout all repositories
    - checkout: self
      path: s/${{ parameters.projectPath }}
      clean: true

    # Check all parameters
    - task: Bash@3
      displayName: Check parameters
      timeoutInMinutes: 5
      inputs:
        targetType: 'inline'
        script: |
          #!/bin/bash
          set -e
        
          # Ensure required parameters are not empty
          if [ -z "${{ parameters.registryServiceConnection }}" ]; then
            echo "##[error] Parameter registryServiceConnection must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.registry }}" ]; then
            echo "##[error] Parameter registry must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.projectPath }}" ]; then
            echo "##[error] Parameter projectPath must not be empty!"
            exit 1
          fi

          # Check if id parameter contains invalid characters
          if [ ! -z "${{ parameters.id }}" ]; then
            if echo "${{ parameters.id }}" | grep -q '[^a-zA-Z0-9_]'; then
              echo "##[error] Parameter id has to consist of characters, numbers and _ only!"
              exit 1
            fi
          fi

          # Generate a configuration file with all the pipeline parameters.
          # This file will be saved in the workspace directory.
          cat > "$(Pipeline.Workspace)/config${{ parameters.id }}.md" <<EOF

          # Parameters
              id:                             ${{ parameters.id }}
              registryServiceConnection:      ${{ parameters.registryServiceConnection }}
              registry:                       ${{ parameters.registry }}
              agentPool:                      ${{ parameters.agentPool }}
              condition:                      ${{ parameters.condition }}
              dependsOn:                      ${{ parameters.dependsOn }}
              projectPath:                    ${{ parameters.projectPath }}
              jobTimeoutInMinutes:            ${{ parameters.jobTimeoutInMinutes }}
              predefinedImageTag:             ${{ parameters.predefinedImageTag }}
              predefinedImageName:            ${{ parameters.predefinedImageName }}
              lockImages:                     ${{ parameters.lockImages }}
              retagExistingImages:            ${{ parameters.retagExistingImages }}
          EOF

    # Generate the Docker image tag that should be used in this build.
    - task: Bash@3
      name: setvarTag
      displayName: 'Set Tag'
      env:
        PREDEFINED_TAG: '${{ parameters.predefinedImageTag }}'
      inputs:
        targetType: inline
        script: |
          #!/bin/bash
          set -e

          # Check if PREDEFINED_TAG is set, use it as tag if it exists
          if [ ! -z "${PREDEFINED_TAG}" ]; then
            DEFINED_TAG="${PREDEFINED_TAG}"
          # If no PREDEFINED_TAG is set, check if the source branch is a tag and use it as tag
          elif [[ $(Build.SourceBranch) =~ tags/(.*) ]]; then
            DEFINED_TAG="${BASH_REMATCH[1]}"
            # Pattern to remove invalid characters
            # See: https://docs.docker.com/engine/reference/commandline/tag/
            pattern="[^a-zA-Z0-9_\.\\-]"
            DEFINED_TAG=$(echo "${DEFINED_TAG}" | sed "s/$pattern//g")
          # If neither a PREDEFINED_TAG is set nor it is a tagged build, use the build id as tag
          else
            DEFINED_TAG="$(build.buildId)"
          fi

          # Set variable 'tag' to DEFINED_TAG
          echo "##vso[task.setvariable variable=tag]${DEFINED_TAG}"

          # Print DEFINED_TAG for debugging purposes
          echo "DEFINED_TAG = ${DEFINED_TAG}"

     # Generate or define the image names to be used in this build.
    - task: Bash@3
      name: setvarImageName
      displayName: 'Set ImageName'
      env:
        PREDEFINED_IMAGE_NAME: ${{ parameters.predefinedImageName }} # optional predefined image name
        SSR_BASE_IMAGE_NAME: ${{ parameters.ssrBaseImageName }} # SSR base image name
        NGINX_BASE_IMAGE_NAME: ${{ parameters.nginxBaseImageName }} # Nginx base image name
      inputs:
        targetType: inline
        script: |
          #!/bin/bash
          set -e

          # Extract the Azure Devops organization name after "ish-"
          ADO_ORGA_NAME=$(echo $(System.CollectionUri) | sed 's|https://dev.azure.com/\(.*\)\(/*\)|\1|; s/.*-//; s|/$||')
          echo "ADO_ORGA_NAME = ${ADO_ORGA_NAME}"

          # Check if PREDEFINED_IMAGE_NAME is set, use it as imageName if it exists
          if [ ! -z "$PREDEFINED_IMAGE_NAME" ]; then
            DEFINED_IMAGE_NAME="${PREDEFINED_IMAGE_NAME}"
          # If this is a tagged build, set the image name to "<ado_orga_name>/team_project"
          elif [[ $(Build.SourceBranch) =~ tags/(.*) ]]; then
            DEFINED_IMAGE_NAME="${ADO_ORGA_NAME}/$(System.TeamProject)"
          # Extract branch name before the first "/", remove non-ASCII characters, and limit to 20 characters
          else
            BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | cut -d'/' -f1 | iconv -f utf-8 -t ascii//translit | cut -c -20)
            DEFINED_IMAGE_NAME="${ADO_ORGA_NAME}/$(System.TeamProject)/${BRANCH_NAME}"
          fi

          # Set variable for the image name
          echo "##vso[task.setvariable variable=imageName]${DEFINED_IMAGE_NAME}"
          echo "DEFINED_IMAGE_NAME = ${DEFINED_IMAGE_NAME}"

          # Set variable for the SSR image name
          DEFINED_IMAGE_NAME_SSR="${DEFINED_IMAGE_NAME}/${SSR_BASE_IMAGE_NAME}"
          echo "##vso[task.setvariable variable=imageNameSSR]${DEFINED_IMAGE_NAME_SSR}"
          echo "DEFINED_IMAGE_NAME_SSR = ${DEFINED_IMAGE_NAME_SSR}"

          # Set variable for the Nginx image name
          DEFINED_IMAGE_NAME_NGINIX="${DEFINED_IMAGE_NAME}/${NGINX_BASE_IMAGE_NAME}"
          echo "##vso[task.setvariable variable=imageNameNginx]${DEFINED_IMAGE_NAME_NGINIX}"
          echo "DEFINED_IMAGE_NAME_NGINIX = ${DEFINED_IMAGE_NAME_NGINIX}"

    - task: Docker@2
      displayName: Docker login
      inputs:
        command: login
        containerRegistry: $(REPO_SERVICE_CONNECTION)

    - task: AzureCLI@2
      timeoutInMinutes: 5
      condition: and(succeeded(), eq('${{ parameters.retagExistingImages }}', true), startsWith(variables['Build.SourceBranch'], 'refs/tags/'))
      displayName: "Retag existing Images"
      env:
        IMAGE_ARTIFACT_FILE_PATH: $(Agent.TempDirectory)/image/imageProperties.yaml
        REGISTRY: ${{ parameters.registry }}
      inputs:
        azureSubscription: '$(REPO_SERVICE_CONNECTION_ARM)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |

          #!/bin/bash

          # This script pulls a Docker image from a registry, renames/retags it with a target version and pushes it back to the same registry.

          # Log in to Azure DevOps
          echo "$(System.AccessToken)" | az devops login --organization "$(System.CollectionUri)"

          # Get the last successful build ID for this commit
          LAST_SUCCESS_BUILD_ID=$(az pipelines runs list \
            --org $(System.CollectionUri) \
            --project $(System.TeamProjectId) \
            --pipeline-ids $(System.DefinitionId) \
            --query-order FinishTimeDesc \
            --result succeeded \
            --status completed \
            --query "[?sourceVersion=='$(Build.SourceVersion)'].id | [0]" -o tsv
          )

          echo "LAST_SUCCESS_BUILD_ID: ${LAST_SUCCESS_BUILD_ID}"

          # Check if the variable is empty
          if [[ -z "${LAST_SUCCESS_BUILD_ID}" ]]; then
            echo "The variable LAST_SUCCESS_BUILD_ID is empty."
            exit 0
          fi

          # Find the download URL of the artifact
          ARTIFACT_DOWNLOAD_URL=$(az pipelines runs artifact list \
            --run-id "${LAST_SUCCESS_BUILD_ID}" \
            --org "$(System.CollectionUri)" \
            --project "$(System.TeamProjectId)" \
            --query "[?name=='image_artifacts'].resource.downloadUrl" -o tsv)

          echo "ARTIFACT_DOWNLOAD_URL: ${ARTIFACT_DOWNLOAD_URL}"

          # Check if the variable is empty
          if [[ -z "${ARTIFACT_DOWNLOAD_URL}" ]]; then
            echo "The variable ARTIFACT_DOWNLOAD_URL is empty."
            exit 0
          fi

          curl \
            -o $(Agent.TempDirectory)/artifact.zip \
            -L "${ARTIFACT_DOWNLOAD_URL}" \
            -H "Authorization: Bearer $(System.AccessToken)"
          
          unzip -q $(Agent.TempDirectory)/artifact.zip -d $(Agent.TempDirectory)

          # Check if the image artifact file exists
          if [[ ! -f "${IMAGE_ARTIFACT_FILE_PATH}" ]]; then
            echo "File: ${IMAGE_ARTIFACT_FILE_PATH} not exists."
            exit 0
          fi

          IMAGE_TAG_SSR=$(yq '.images[] | select(.type == "ssr") | .tag // ""' ${IMAGE_ARTIFACT_FILE_PATH})
          IMAGE_DIGEST_SSR=$(yq '.images[] | select(.type == "ssr") | .digest // ""' ${IMAGE_ARTIFACT_FILE_PATH})
          IMAGE_NAME_SSR=$(yq '.images[] | select(.type == "ssr") | .name // ""' ${IMAGE_ARTIFACT_FILE_PATH})
          IMAGE_REGISTRY_SSR=$(yq '.images[] | select(.type == "ssr") | .registry // ""' ${IMAGE_ARTIFACT_FILE_PATH})

          IMAGE_TAG_NGINX=$(yq '.images[] | select(.type == "nginx") | .tag // ""' ${IMAGE_ARTIFACT_FILE_PATH})
          IMAGE_DIGEST_NGINX=$(yq '.images[] | select(.type == "nginx") | .digest // ""' ${IMAGE_ARTIFACT_FILE_PATH})
          IMAGE_NAME_NGINX=$(yq '.images[] | select(.type == "nginx") | .name // ""' ${IMAGE_ARTIFACT_FILE_PATH})
          IMAGE_REGISTRY_NGINX=$(yq '.images[] | select(.type == "nginx") | .registry // ""' ${IMAGE_ARTIFACT_FILE_PATH})

          # Check if IMAGE_TAG, IMAGE_DIGEST, IMAGE_NAME or IMAGE_REGISTRY are empty or null
          if [[ -z "${IMAGE_TAG_SSR}" || -z "${IMAGE_DIGEST_SSR}" || -z "${IMAGE_NAME_SSR}" || -z "${IMAGE_REGISTRY_SSR}" ]]; then
            echo "##[error] Invalid image mapping. IMAGE_TAG_SSR, IMAGE_DIGEST_SSR, IMAGE_NAME_SSR or IMAGE_REGISTRY_SSR is empty or null."
            exit 0
          fi
          if [[ -z "${IMAGE_TAG_NGINX}" || -z "${IMAGE_DIGEST_NGINX}" || -z "${IMAGE_NAME_NGINX}" || -z "${IMAGE_REGISTRY_NGINX}" ]]; then
            echo "##[error] Invalid image mapping. IMAGE_TAG_NGINX, IMAGE_DIGEST_NGINX, IMAGE_NAME_NGINX or IMAGE_REGISTRY_NGINX is empty or null."
            exit 0
          fi

          # Check if the image registry matches the expected registry
          if [[ "${IMAGE_REGISTRY_SSR}" != "${REGISTRY}" || "${IMAGE_REGISTRY_NGINX}" != "${REGISTRY}" ]]; then
            echo "The strings REGISTRY and IMAGE_REGISTRY_SSR|IMAGE_REGISTRY_NGINX are not equal."
            exit 0
          fi

          # Get the image digest from the Azure Container Registry
          ACR_IMAGE_DIGEST_SSR=$(az acr repository show \
            -n "${IMAGE_REGISTRY_SSR}" \
            --image "${IMAGE_NAME_SSR}@${IMAGE_DIGEST_SSR}" \
            --query "digest" \
            -o tsv)

          echo "ACR_IMAGE_DIGEST_SSR: ${ACR_IMAGE_DIGEST_SSR}"

          ACR_IMAGE_DIGEST_NGINX=$(az acr repository show \
            -n "${IMAGE_REGISTRY_NGINX}" \
            --image "${IMAGE_NAME_NGINX}@${IMAGE_DIGEST_NGINX}" \
            --query "digest" \
            -o tsv)

          echo "ACR_IMAGE_DIGEST_NGINX: ${ACR_IMAGE_DIGEST_NGINX}"

          # Check if the variable is empty
          if [[ -z "${ACR_IMAGE_DIGEST_SSR}" || -z "${ACR_IMAGE_DIGEST_NGINX}" ]]; then
            echo "The variable ACR_IMAGE_DIGEST_SSR|ACR_IMAGE_DIGEST_NGINX is empty."
            exit 0
          fi

          # Check if the image digest matches the expected digest
          if [[ "${ACR_IMAGE_DIGEST_SSR}" != "${IMAGE_DIGEST_SSR}" || "${ACR_IMAGE_DIGEST_NGINX}" != "${IMAGE_DIGEST_NGINX}" ]]; then
            echo "The strings ACR_IMAGE_DIGEST_SSR|ACR_IMAGE_DIGEST_NGINX and IMAGE_DIGEST_SSR|IMAGE_DIGEST_NGINX are not equal."
            exit 0
          fi

          # Change to the project directory
          cd "${{ parameters.projectPath }}"

          # Pull the Docker image
          docker pull "${IMAGE_REGISTRY_SSR}/${IMAGE_NAME_SSR}@${IMAGE_DIGEST_SSR}" || exit 0
          docker pull "${IMAGE_REGISTRY_NGINX}/${IMAGE_NAME_NGINX}@${IMAGE_DIGEST_NGINX}" || exit 0

          # Echo the pull success message
          echo "Docker image '${IMAGE_REGISTRY_SSR}/${IMAGE_NAME_SSR}@${IMAGE_DIGEST_SSR}' was successfully pulled."
          echo "Docker image '${IMAGE_REGISTRY_NGINX}/${IMAGE_NAME_NGINX}@${IMAGE_DIGEST_NGINX}' was successfully pulled."

          # Rename and push the Docker image
          docker tag "${IMAGE_REGISTRY_SSR}/${IMAGE_NAME_SSR}@${IMAGE_DIGEST_SSR}" "${REGISTRY}/$(imageNameSSR):$(tag)" || exit 0
          docker tag "${IMAGE_REGISTRY_NGINX}/${IMAGE_NAME_NGINX}@${IMAGE_DIGEST_NGINX}" "${REGISTRY}/$(imageNameNginx):$(tag)" || exit 0

          docker push "${REGISTRY}/$(imageNameSSR):$(tag)" || exit 0
          docker push "${REGISTRY}/$(imageNameNginx):$(tag)" || exit 0

          # Echo the push success message
          echo "Docker image was successfully pushed to the repository '${REGISTRY}/$(imageNameSSR):$(tag)'."
          echo "Docker image was successfully pushed to the repository '${REGISTRY}/$(imageNameNginx):$(tag)'."

          echo "##vso[task.setvariable variable=imageRetagged;]true"
    #
    # SSR-Container
    #
    - task: Docker@2
      displayName: SSR Docker build
      condition: and(succeeded(), ne(variables.imageRetagged, true))
      inputs:
        containerRegistry: $(REPO_SERVICE_CONNECTION)
        repository: '$(imageNameSSR)'
        command: 'build'
        Dockerfile: '$(system.defaultWorkingDirectory)/Dockerfile'
        buildContext: '$(system.defaultWorkingDirectory)'
        tags: $(tag)
        arguments: '--build-arg displayVersion=$(tag)'

    - task: Docker@2
      displayName: SSR Docker push
      condition: and(succeeded(), ne(variables.imageRetagged, true))
      inputs:
        containerRegistry: '$(REPO_SERVICE_CONNECTION)'
        repository: '$(imageNameSSR)'
        command: 'push'
        tags: $(tag)
    
    #
    # Nginx Container
    #

    - task: Docker@2
      displayName: Nginx Docker build
      condition: and(succeeded(), ne(variables.imageRetagged, true))
      inputs:
        containerRegistry: $(REPO_SERVICE_CONNECTION)
        repository: '$(imageNameNginx)'
        command: 'build'
        Dockerfile: '$(system.defaultWorkingDirectory)/nginx/Dockerfile'
        buildContext: '$(system.defaultWorkingDirectory)/nginx'
        tags: $(tag)

    - task: Docker@2
      displayName: Nginx Docker push
      condition: and(succeeded(), ne(variables.imageRetagged, true))
      inputs:
        containerRegistry: '$(REPO_SERVICE_CONNECTION)'
        repository: '$(imageNameNginx)'
        command: 'push'
        tags: $(tag)

    #
    # Post steps
    #

    # Generate a build information file and push it as a pipeline artifact.
    - task: Bash@3
      displayName: Create Image Version Overview
      timeoutInMinutes: 5
      env:
        TAG: $(tag)
        IMAGE_SSR: $(imageNameSSR)
        IMAGE_NGINX: $(imageNameNginx)
        REGISTRY: ${{ parameters.registry }}
      inputs:
        targetType: 'inline'
        script: |
          #!/bin/bash
          set -e

          # This script reads the labels of a Docker image and creates an imageProperty file.

          # Create a temporary directory with a unique name
          TMP_CUSTOM_DIR=$(mktemp -d -t ci-pwa-XXXXXXXXXX)
          IMAGE_PROPERTIES_FILE="${TMP_CUSTOM_DIR}/imageProperties.yaml"

          # Check if the IMAGE_SSR variable is empty
          if [[ -z "${IMAGE_SSR}" ]]; then
              echo "The IMAGE_SSR variable is empty."
              exit 1
          fi

          # Check if the IMAGE_NGINX variable is empty
          if [[ -z "${IMAGE_NGINX}" ]]; then
              echo "The IMAGE_NGINX variable is empty."
              exit 1
          fi

          # Check if the ssr Docker image is present on the local system
          if docker image inspect ${REGISTRY}/${IMAGE_SSR}:${TAG} >/dev/null 2>&1; then
            echo "The Docker image ${REGISTRY}/${IMAGE_SSR}:${TAG} is present on the local system."
          else
            echo "The Docker image ${REGISTRY}/${IMAGE_SSR}:${TAG} is NOT present on the local system."
            exit 1
          fi

          # Check if the nginx Docker image is present on the local system
          if docker image inspect ${REGISTRY}/${IMAGE_NGINX}:${TAG} >/dev/null 2>&1; then
            echo "The Docker image ${REGISTRY}/${IMAGE_NGINX}:${TAG} is present on the local system."
          else
            echo "The Docker image ${REGISTRY}/${IMAGE_NGINX}:${TAG} is NOT present on the local system."
            exit 1
          fi

          # Get Image digest
          IMAGE_DIGIST_SSR=$(docker image inspect --format='{{index .RepoDigests 0}}' "${REGISTRY}/${IMAGE_SSR}:${TAG}" | cut -d'@' -f2)
          IMAGE_DIGIST_NGINX=$(docker image inspect --format='{{index .RepoDigests 0}}' "${REGISTRY}/${IMAGE_NGINX}:${TAG}" | cut -d'@' -f2)

          # Write the ssr and nginx repository name and tag to the imageProperties file
          # Generate YAML file
          cat <<EOF > ${IMAGE_PROPERTIES_FILE}
          images:
            - type: ssr
              tag: ${TAG}
              name: ${IMAGE_SSR}
              digest: ${IMAGE_DIGIST_SSR}
              registry: ${REGISTRY}
            - type: nginx
              tag: ${TAG}
              name: ${IMAGE_NGINX}
              digest: ${IMAGE_DIGIST_NGINX}
              registry: ${REGISTRY}
          EOF
  
          # Print the contents of the imageProperties file
          echo "###### File ${IMAGE_PROPERTIES_FILE} ######"
          cat ${IMAGE_PROPERTIES_FILE}
          echo "###### File end ######"

          # Validate YAML
          if yq ${IMAGE_PROPERTIES_FILE} >/dev/null; then
              echo "YAML file generated successfully."
          else
              echo "Failed to generate YAML file."
              exit 1
          fi

          # Upload the imageProperties file as an artifact
          echo "##vso[artifact.upload containerfolder=image;artifactname=image_artifacts]${IMAGE_PROPERTIES_FILE}"

          cat >> "$(Pipeline.Workspace)/config${{ parameters.id }}.md" <<EOF

          # Created Docker image
              ssr-image:                             ${REGISTRY}/${IMAGE_SSR}:${TAG}
              nginx-image:                           ${REGISTRY}/${IMAGE_NGINX}:${TAG}
              
          EOF
      
    # If the parameter lockImages is true and the Build.SourceBranch is a tag, 
    # then the generated Docker images in the ACR will be made non-overwritable and non-deletable.
    - task: AzureCLI@2
      timeoutInMinutes: 5
      condition: and(succeeded(), eq('${{ parameters.lockImages }}', true), startsWith(variables['Build.SourceBranch'], 'refs/tags/'))
      displayName: "Set image attributes"
      env:
        TAG: $(tag)
        IMAGE_NAME_NGINX: $(imageNameNginx)
        IMAGE_NAME_SSR: $(imageNameSSR)
        REGISTRY: ${{ parameters.registry }}
      inputs:
        azureSubscription: '$(REPO_SERVICE_CONNECTION_ARM)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |

          #!/bin/bash
          set -e

          # Update the ssr image
          az acr repository update \
            --name "${REGISTRY}" \
            --image "${IMAGE_NAME_SSR}:${TAG}" \
            --delete-enabled false \
            --write-enabled false
           
          # Update the nginx image
          az acr repository update \
            --name "${REGISTRY}" \
            --image "${IMAGE_NAME_NGINX}:${TAG}" \
            --delete-enabled false \
            --write-enabled false
    
    # Clean up all Docker resources generated by the build.        
    - task: Bash@3
      displayName: Docker Cleanup
      timeoutInMinutes: 10
      condition: always()
      inputs:
        targetType: 'inline'
        script: |

          # Stop all containers
          if [[ -n $(docker container ls -a -q) ]]; then docker container stop $(docker container ls -a -q); fi
          # Remove all unused containers, networks, images and volumes.
          docker system prune -a -f --volumes

    # Upload build summary file. The summary will appear on an Extensions tab.
    - task: Bash@3
      timeoutInMinutes: 5
      condition: always()
      continueOnError: true
      displayName: "Provide pipeline configuration"
      inputs:
        targetType: 'inline'
        script: |
          set -e
          echo "##vso[task.uploadsummary]$(Pipeline.Workspace)/config${{ parameters.id }}.md"
