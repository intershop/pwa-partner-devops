################################################################################
# Parameters have to be specified by the caller, to customize the pipeline
# for a certain project
################################################################################
parameters:

  # Identifies each job uniquely when ci-job-template.yml is used in a loop. 
  # Can only contain characters, numbers, and underscores.
  # Also used to extend names of files published in extensions.
- name: id
  type: string
  default: ''
  
  # Enables an easy integration with custom jobs. 
  # The parameter will be passed as is to the 'dependsOn' property of the job.
- name: dependsOn
  type: string
  default: ''

  # Enables an easy integration with custom jobs. 
  # The parameter will be passed as is to the 'condition' property of the job.
- name: condition
  type: string
  default: ''

  # Specifies the name of the agent pool.
- name: agentPool
  type: string
  default: ''

  # Defines the service connection to the Registry/ACR of the project.
- name: registryServiceConnection
  type: string
  default: '$(REPO_SERVICE_CONNECTION)'

  # Specifies the repository in Registry/ACR url.
- name: registry
  type: string
  default: ''

  # Specifies the name of the repository.
- name: projectPath
  type: string
  default: '$(Build.Repository.Name)'

  # Specifies a predefined image tag. 
  # If not set, it will be generated by build ID or tag value.
- name: predefinedImageTag
  type: string
  default: ''

  # Specifies a prefix for the image tag when generating it.
  # This parameter is not used if the parameter predefinedImageTag is set 
  # or if the build is based on a tag.
- name: imageTagPrefix
  type: string
  default: ''

  # Specifies a predefined image name. If not set, it will be generated by 
  # $(System.CollectionUri) and $(System.TeamProject) and $(Build.SourceBranchName).
- name: predefinedImageName
  type: string
  default: ''

  # Specifies the separator to be used in the image names (e.g. "/" or "-").
- name: imageNameSeparator
  type: string
  default: '/'

  # Specifies the name of the predefined SSR container.
- name: ssrBaseImageName
  type: string
  default: 'pwa-ssr'

  # Specifies the name of the predefined Nginx container.
- name: nginxBaseImageName
  type: string
  default: 'pwa-nginx'

  # Specifies the path to the Dockerfile for the SSR build.
- name: ssrDockerfilePath
  type: string
  default: 'Dockerfile'

  # Specifies the path to the Dockerfile for the Nginx build.
- name: nginxDockerfilePath
  type: string
  default: 'nginx/Dockerfile'

  # Specifies the build context for the Nginx Docker build.
- name: nginxBuildContext
  type: string
  default: 'nginx'

  # Specifies additional build arguments for the SSR Docker build.
- name: ssrAdditionalBuildArgs
  type: string
  default: ''

  # Specifies additional build arguments for the Nginx Docker build.
- name: nginxAdditionalBuildArgs
  type: string
  default: ''

  # Enable immutable images when created for Git tags.
- name: lockImages
  type: boolean
  default: true
  
  # Specifies the maximum job execution time in minutes.
- name: jobTimeoutInMinutes
  type: number
  default: 300

  # Specifies whether future jobs should run even if this job fails.
- name: jobContinueOnError
  type: boolean
  default: false

jobs:
- job: CI${{ parameters.id }}
  pool: '${{ parameters.agentPool }}'
  dependsOn: ${{ parameters.dependsOn }}
  condition: ${{ parameters.condition }}
  continueOnError: ${{ parameters.jobContinueOnError }}
  timeoutInMinutes: ${{ parameters.jobTimeoutInMinutes }}
  workspace:
    clean: all
  steps:
    # Checkout all repositories
    - checkout: self
      path: s/${{ parameters.projectPath }}
      clean: true

    # Check all parameters
    - task: Bash@3
      displayName: Check parameters
      timeoutInMinutes: 5
      inputs:
        targetType: 'inline'
        script: |
          #!/bin/bash
          set -e
        
          # Ensure required parameters are not empty
          if [ -z "${{ parameters.registryServiceConnection }}" ]; then
            echo "##[error] Parameter registryServiceConnection must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.registry }}" ]; then
            echo "##[error] Parameter registry must not be empty!"
            exit 1
          fi
          if [ -z "${{ parameters.projectPath }}" ]; then
            echo "##[error] Parameter projectPath must not be empty!"
            exit 1
          fi

          # Check if id parameter contains invalid characters
          if [ ! -z "${{ parameters.id }}" ]; then
            if echo "${{ parameters.id }}" | grep -q '[^a-zA-Z0-9_]'; then
              echo "##[error] Parameter id has to consist of characters, numbers and _ only!"
              exit 1
            fi
          fi

          # Generate a configuration file with all the pipeline parameters.
          # This file will be saved in the workspace directory.
          cat > "$(Pipeline.Workspace)/config${{ parameters.id }}.md" <<EOF

          # Parameters
              id:                             ${{ parameters.id }}
              registryServiceConnection:      ${{ parameters.registryServiceConnection }}
              registry:                       ${{ parameters.registry }}
              agentPool:                      ${{ parameters.agentPool }}
              condition:                      ${{ parameters.condition }}
              dependsOn:                      ${{ parameters.dependsOn }}
              projectPath:                    ${{ parameters.projectPath }}
              jobTimeoutInMinutes:            ${{ parameters.jobTimeoutInMinutes }}
              predefinedImageTag:             ${{ parameters.predefinedImageTag }}
              imageTagPrefix:                 ${{ parameters.imageTagPrefix }}
              predefinedImageName:            ${{ parameters.predefinedImageName }}
              imageNameSeparator:             ${{ parameters.imageNameSeparator }}
              ssrBaseImageName:               ${{ parameters.ssrBaseImageName }}
              nginxBaseImageName:             ${{ parameters.nginxBaseImageName }}
              ssrDockerfilePath:              ${{ parameters.ssrDockerfilePath }}
              nginxDockerfilePath:            ${{ parameters.nginxDockerfilePath }}
              nginxBuildContext:              ${{ parameters.nginxBuildContext }}
              ssrAdditionalBuildArgs:         ${{ parameters.ssrAdditionalBuildArgs }}
              nginxAdditionalBuildArgs:       ${{ parameters.nginxAdditionalBuildArgs }}
              lockImages:                     ${{ parameters.lockImages }}
          EOF

    # Generate the Docker image tag that should be used in this build.
    - task: Bash@3
      name: setvarTag
      displayName: 'Set Tag'
      env:
        PREDEFINED_TAG: '${{ parameters.predefinedImageTag }}'
        IMAGE_TAG_PREFIX: '${{ parameters.imageTagPrefix }}'
      inputs:
        targetType: inline
        script: |
          #!/bin/bash
          set -e

          # Check if PREDEFINED_TAG is set, use it as tag if it exists
          if [ ! -z "${PREDEFINED_TAG}" ]; then
            DEFINED_TAG="${PREDEFINED_TAG}"
          # If no PREDEFINED_TAG is set, check if the source branch is a tag and use it as tag
          elif [[ "${BUILD_SOURCEBRANCH}" =~ tags/(.*) ]]; then
            DEFINED_TAG="${BASH_REMATCH[1]##*/}"
            # Pattern to remove invalid characters
            # See: https://docs.docker.com/engine/reference/commandline/tag/
            pattern="[^a-zA-Z0-9_\.\\-]"
            DEFINED_TAG=$(echo "${DEFINED_TAG}" | sed "s/$pattern//g")
          # If neither a PREDEFINED_TAG is set nor it is a tagged build, use the build id as tag
          else
            DEFINED_TAG="${IMAGE_TAG_PREFIX}${BUILD_BUILDID}"
          fi

          # Set variable 'tag' to DEFINED_TAG
          echo "##vso[task.setvariable variable=tag]${DEFINED_TAG}"

          # Print DEFINED_TAG for debugging purposes
          echo "DEFINED_TAG = ${DEFINED_TAG}"

     # Generate or define the image names to be used in this build.
    - task: Bash@3
      name: setvarImageName
      displayName: 'Set ImageName'
      env:
        PREDEFINED_IMAGE_NAME: ${{ parameters.predefinedImageName }} # optional predefined image name
        SSR_BASE_IMAGE_NAME: ${{ parameters.ssrBaseImageName }} # SSR base image name
        NGINX_BASE_IMAGE_NAME: ${{ parameters.nginxBaseImageName }} # Nginx base image name
        IMAGE_NAME_SEPARATOR: ${{ parameters.imageNameSeparator }}
      inputs:
        targetType: inline
        script: |
          #!/bin/bash
          set -e

          # Extract the Azure Devops organization name after "ish-"
          ADO_ORGA_NAME=$(echo $(System.CollectionUri) | sed 's|https://dev.azure.com/\(.*\)\(/*\)|\1|; s/.*-//; s|/$||')
          echo "ADO_ORGA_NAME = ${ADO_ORGA_NAME}"

          # Check if PREDEFINED_IMAGE_NAME is set, use it as imageName if it exists
          if [ ! -z "$PREDEFINED_IMAGE_NAME" ]; then
            DEFINED_IMAGE_NAME="${PREDEFINED_IMAGE_NAME}"
          # If this is a tagged build, set the image name to "<ado_orga_name>/team_project"
          elif [[ $(Build.SourceBranch) =~ tags/(.*) ]]; then
            DEFINED_IMAGE_NAME="${ADO_ORGA_NAME}/$(System.TeamProject)"
          # Extract branch name before the first "/", remove non-ASCII characters, and limit to 20 characters
          else
            BRANCH_NAME=$(echo "$(Build.SourceBranchName)" | cut -d'/' -f1 | iconv -f utf-8 -t ascii//translit | cut -c -20)
            DEFINED_IMAGE_NAME="${ADO_ORGA_NAME}/$(System.TeamProject)/${BRANCH_NAME}"
          fi

          # Convert DEFINED_IMAGE_NAME to lowercase and remove spaces
          DEFINED_IMAGE_NAME=$(echo "$DEFINED_IMAGE_NAME" | tr '[:upper:]' '[:lower:]' | tr -d ' ')

          # Set variable for the image name
          echo "##vso[task.setvariable variable=imageName]${DEFINED_IMAGE_NAME}"
          echo "DEFINED_IMAGE_NAME = ${DEFINED_IMAGE_NAME}"

          # Set variable for the SSR image name
          DEFINED_IMAGE_NAME_SSR="${DEFINED_IMAGE_NAME}${IMAGE_NAME_SEPARATOR}${SSR_BASE_IMAGE_NAME}"
          echo "##vso[task.setvariable variable=imageNameSSR]${DEFINED_IMAGE_NAME_SSR}"
          echo "DEFINED_IMAGE_NAME_SSR = ${DEFINED_IMAGE_NAME_SSR}"

          # Set variable for the Nginx image name
          DEFINED_IMAGE_NAME_NGINIX="${DEFINED_IMAGE_NAME}${IMAGE_NAME_SEPARATOR}${NGINX_BASE_IMAGE_NAME}"
          echo "##vso[task.setvariable variable=imageNameNginx]${DEFINED_IMAGE_NAME_NGINIX}"
          echo "DEFINED_IMAGE_NAME_NGINIX = ${DEFINED_IMAGE_NAME_NGINIX}"

    #
    # SSR-Container
    #
    - task: Docker@2
      displayName: SSR Docker login
      inputs:
        command: login
        containerRegistry: '${{ parameters.registryServiceConnection }}'

    - task: Docker@2
      displayName: SSR Docker build
      inputs:
        containerRegistry: '${{ parameters.registryServiceConnection }}'
        repository: '$(imageNameSSR)'
        command: 'build'
        Dockerfile: '$(Pipeline.Workspace)/s/${{ parameters.projectPath }}/${{ parameters.ssrDockerfilePath }}'
        buildContext: '$(Pipeline.Workspace)/s/${{ parameters.projectPath }}'
        tags: $(tag)
        arguments: '--build-arg displayVersion=$(tag) ${{ parameters.ssrAdditionalBuildArgs }}'

    - task: Docker@2
      displayName: SSR Docker push
      inputs:
        containerRegistry: '${{ parameters.registryServiceConnection }}'
        repository: '$(imageNameSSR)'
        command: 'push'
        tags: $(tag)
    
    #
    # Nginx Container
    #
    - task: Docker@2
      displayName: Nginx Docker login
      inputs:
        command: login
        containerRegistry: '${{ parameters.registryServiceConnection }}'

    - task: Docker@2
      displayName: Nginx Docker build
      inputs:
        containerRegistry: '${{ parameters.registryServiceConnection }}'
        repository: '$(imageNameNginx)'
        command: 'build'
        Dockerfile: '$(Pipeline.Workspace)/s/${{ parameters.projectPath }}/${{ parameters.nginxDockerfilePath }}'
        buildContext: '$(Pipeline.Workspace)/s/${{ parameters.projectPath }}/${{ parameters.nginxBuildContext }}'
        tags: $(tag)
        arguments: '--build-arg displayVersion=$(tag) ${{ parameters.nginxAdditionalBuildArgs }}'

    - task: Docker@2
      displayName: Nginx Docker push
      inputs:
        containerRegistry: '${{ parameters.registryServiceConnection }}'
        repository: '$(imageNameNginx)'
        command: 'push'
        tags: $(tag)

    #
    # Post steps
    #

    # Generate a build information file and push it as a pipeline artifact.
    - task: Bash@3
      displayName: Create Image Version Overview
      timeoutInMinutes: 5
      env:
        TAG: $(tag)
        IMAGE_SSR: $(imageNameSSR)
        IMAGE_NGINX: $(imageNameNginx)
        REGISTRY: ${{ parameters.registry }}
      inputs:
        targetType: 'inline'
        script: |
          #!/bin/bash
          set -e

          #######################################
          # The script is checking if the IMAGE_SSR and IMAGE_NGINX environment variables are empty. 
          # If they are empty, the script exits with an error. 
          # If they are not empty, the script writes the values of these variables to a temporary file named imageProperties. 
          # The script also checks if the Docker images exist locally and exits with an error if they don't exist.
          # Finally, the script prints the contents of the imageProperties file and uploads it as an pipeline artifact. 
          # It also appends information about the created Docker image to a Markdown file named config<id>.md.
          #
          # Arguments:
          #   None
          #######################################

          ###############################################################
          # Script Parameters                                           #
          ###############################################################

          # Create a temporary folder for storing intermediate files

          # Create a temporary directory with a unique name
          TMP_CUSTOM_DIR=$(mktemp -d -t ci-pwa-XXXXXXXXXX)
          IMAGE_PROPERTIES_FILE="${TMP_CUSTOM_DIR}/imageProperties.yaml"

          ###############################################################
          # Script                                                      #
          ###############################################################

          # Check if the IMAGE_SSR variable is empty
          if [ -z "${IMAGE_SSR}" ]; then
              echo "The IMAGE_SSR variable is empty."
              exit 1
          fi

          # Check if the IMAGE_NGINX variable is empty
          if [ -z "${IMAGE_NGINX}" ]; then
              echo "The IMAGE_NGINX variable is empty."
              exit 1
          fi

          # Check if the ssr Docker image is present on the local system
          if docker image inspect ${REGISTRY}/${IMAGE_SSR}:${TAG} >/dev/null 2>&1; then
            echo "The Docker image ${REGISTRY}/${IMAGE_SSR}:${TAG} is present on the local system."
          else
            echo "The Docker image ${REGISTRY}/${IMAGE_SSR}:${TAG} is NOT present on the local system."
            exit 1
          fi

          # Check if the nginx Docker image is present on the local system
          if docker image inspect ${REGISTRY}/${IMAGE_NGINX}:${TAG} >/dev/null 2>&1; then
            echo "The Docker image ${REGISTRY}/${IMAGE_NGINX}:${TAG} is present on the local system."
          else
            echo "The Docker image ${REGISTRY}/${IMAGE_NGINX}:${TAG} is NOT present on the local system."
            exit 1
          fi

          # Write the ssr and nginx repository name and tag to the imageProperties file
          # Generate YAML file
          cat <<EOF > ${IMAGE_PROPERTIES_FILE}
          images:
            - type: ssr
              tag: ${TAG}
              name: ${IMAGE_SSR}
              registry: ${REGISTRY}
            - type: nginx
              tag: ${TAG}
              name: ${IMAGE_NGINX}
              registry: ${REGISTRY}
          EOF
  
          # Print the contents of the imageProperties file
          echo "###### File ${IMAGE_PROPERTIES_FILE} ######"
          cat ${IMAGE_PROPERTIES_FILE}
          echo "###### File end ######"

          # Validate YAML
          if yq ${IMAGE_PROPERTIES_FILE} >/dev/null; then
              echo "YAML file generated successfully."
          else
              echo "Failed to generate YAML file."
              exit 1
          fi

          # Upload the imageProperties file as an artifact
          echo "##vso[artifact.upload containerfolder=image;artifactname=image_artifacts]${IMAGE_PROPERTIES_FILE}"

          cat >> "$(Pipeline.Workspace)/config${{ parameters.id }}.md" <<EOF

          # Created Docker image
              ssr-image:                             ${REGISTRY}/${IMAGE_SSR}:${TAG}
              nginx-image:                           ${REGISTRY}/${IMAGE_NGINX}:${TAG}
              
          EOF
      
    # If the parameter lockImages is true and the Build.SourceBranch is a tag, 
    # then the generated Docker images in the ACR will be made non-overwritable and non-deletable.
    - ${{ if parameters.lockImages }}:
      - task: AzureCLI@2
        timeoutInMinutes: 5
        condition: and(succeeded(), eq('${{ parameters.lockImages }}', true), startsWith(variables['Build.SourceBranch'], 'refs/tags/'))
        displayName: "Set image attributes"
        env:
          TAG: $(tag)
          IMAGE_NAME_NGINX: $(imageNameNginx)
          IMAGE_NAME_SSR: $(imageNameSSR)
          REGISTRY: ${{ parameters.registry }}
        inputs:
          azureSubscription: '$(REPO_SERVICE_CONNECTION_ARM)'
          scriptType: bash
          scriptLocation: inlineScript
          inlineScript: |

            #!/bin/bash
            set -e

            # Update the ssr image
            az acr repository update \
              --name "${REGISTRY}" \
              --image "${IMAGE_NAME_SSR}:${TAG}" \
              --delete-enabled false \
              --write-enabled false
            
            # Update the nginx image
            az acr repository update \
              --name "${REGISTRY}" \
              --image "${IMAGE_NAME_NGINX}:${TAG}" \
              --delete-enabled false \
              --write-enabled false
    
    # Clean up all Docker resources generated by the build.        
    - task: Bash@3
      displayName: Docker Cleanup
      timeoutInMinutes: 10
      condition: always()
      inputs:
        targetType: 'inline'
        script: |

          # Stop all containers
          if [[ -n $(docker container ls -a -q) ]]; then docker container stop $(docker container ls -a -q); fi
          # Remove all unused containers, networks, images and volumes.
          docker system prune -a -f --volumes

    # Upload build summary file. The summary will appear on an Extensions tab.
    - task: Bash@3
      timeoutInMinutes: 5
      condition: always()
      continueOnError: true
      displayName: "Provide pipeline configuration"
      inputs:
        targetType: 'inline'
        script: |
          set -e
          echo "##vso[task.uploadsummary]$(Pipeline.Workspace)/config${{ parameters.id }}.md"
    
    # Adds a build tag based on the SourceBranch type (Pull Request, Tag, or Branch) for better build classification.
    - task: Bash@3
      timeoutInMinutes: 1
      condition: always()
      continueOnError: true
      displayName: "Add pipeline tag based on SourceBranch type"
      inputs:
        targetType: 'inline'
        script: |
          #!/bin/bash
          set -e

          echo "Checking Build.SourceBranch: $(Build.SourceBranch)"
    
          if [[ "$(Build.SourceBranch)" =~ ^refs/pull/ ]]; then
              echo "##vso[build.addbuildtag]SourceType_Git-PullRequest"
          elif [[ "$(Build.SourceBranch)" =~ ^refs/tags/ ]]; then
              echo "##vso[build.addbuildtag]SourceType_Git-Tag"
          elif [[ "$(Build.SourceBranch)" =~ ^refs/heads/ ]]; then
              echo "##vso[build.addbuildtag]SourceType_Git-Branch"
          else
              echo "##vso[build.addbuildtag]SourceType_Unknown"
          fi
